# 操作系统—内存管理

iOS操作系统内存管理包括**物理内存管理**和**虚拟内存管理**。

_**物理内存管理**_：包括程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式(分段、分页、段页)。

_**虚拟内存管理**_：包括虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。

## 一、操作系统内存机制

### 1、内存管理目标

#### **内存管理是什么**

计算机不可能将所有用户进程和系统所需全部程序和数据放入主存，因此操作系统必须对内存空间进行合理有效的分配。

内存管理的作用：

* 内存的分配回收：主存储器（物理内存）的分配和管理
* 地址转换：将逻辑地址转换成相应的物理地址
* 内存扩充：利用虚拟存储技术，从逻辑上扩充主存
* 存储保护：保证各进程在各自的存储空间内运行，互不干扰

#### 存储类型：内存、外存

ROM和RAM都是内存

* ROM(Read Only Memory)：只读存储器。系统断电仍可保持数据
* RAM(Read Access Memory)：随机存取存储器。即内存
  * 静态RAM：读取速度快；在要求苛刻的地方使用(如CPU一级、二级、三级缓存)
  * 动态RAM：保留时间短，价格相对便宜

<figure><img src="../.gitbook/assets/image (1) (1).png" alt="" width="375"><figcaption><p>分级存储器</p></figcaption></figure>

存储器的分级实际上就是⼀种缓存思想。⾦字塔底部的部分容量⼤，更便宜，主要是为了发 挥其存储属性；⽽⾦字塔尖的⾼速缓存部分读写速度快，负责将⾼频使⽤的部分缓存起来。

### **2、计算机内存的惰性分配**

计算机物理内存上每个字节都有唯一的物理地址。CPU访问内存通过物理地址直接访问对应的内存。

进程直接使用物理内存空间缺陷：

* 进程malloc分配一块连续的内存空间，可能出现足够的空闲物理内存，但无足够的连续空闲内存
* 四处分散的内存块就是内存碎片，存在不可用浪费
* 进程读写内存的安全问题，跨进程读取未做限制
* 进程执行错误指令可修改其他进程的数据，导致不安全

#### 虚拟内存

虚拟内存的目的是为了让<mark style="color:red;">**物理内存**</mark>扩充成更大的<mark style="color:red;">**逻辑内存**</mark>，从而让程序获得更多的可用内存。

虚拟内存是操作系统对每个进程提供一个独立的、私有的、连续的地址空间。每个进程有独立的逻辑地址空间。

虚拟内存的意义：

* 保护了每个进程的地址空间
* 简化了内存管理
* 利用硬盘空间拓展了内存空间

**内存映射**

只有实际使用的虚拟内存才分配物理内存，分配后的物理内存通过内存映射来管理。

内存映射即将虚拟内存映射到物理内存地址。CPU要访问虚拟内存地址，要经过内存管理单元MMU将虚拟地址翻译成物理地址才能访问。

虚拟地址 = 存储页面号+存储偏移量

**什么是页表**

页表是一种特殊的数据结构，记录了虚拟内存映射到物理内存的状况。当前进程访问某个虚拟地址时，首先查询页面，如果不在，发生缺页异常（Page fault）。

> * malloc申请内存是延时分配，在真正使用时才申请物理内存
> * 发现没有记录才会申请，出现缺页异常，即是内存的惰性分配机制

#### 触发page Fault的原因

* 没有建立虚拟内存—>物理内存的映射
* 访问的地址物理内存中不存在，要从磁盘/SWAP分区读取才能使用
* 访问的地址内存非法，可能导致进程宕掉

### 3、内存分⻚

为了⽅便虚拟内存与物理内存的映射和管理，虚拟内存和物理内存都被分割成相同⼤⼩的单位，物理内存的最⼩单位被称为**帧（Frame）**，⽽虚拟内存的最⼩单位被称为 **⻚（Page）**

内存分页支持了物理内存的离散使用。由于存在映射过程，虚拟内存对应的物理内存可以任意存放，方便了操作系统对物理内存的管理，也最大化利用物理内存。

32位处理器的操作系统创建的进程分配4GB虚拟内存，每页指向4KB物理地址，共有4GB/4KB个页表项 = 1024 \* 1024个页表项。

### 4、分段

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

分段与分页的比较：

* 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
* 地址空间的维度：分页是一维地址空间，分段是二维的。
* 大小是否可以改变：页的大小不可变，段的大小可以动态改变

## 二、iOS内存

### 1、iOS内存机制

* iOS 使用虚拟内存机制。
* 内存有限，但单应⽤可⽤内存⼤
* 没有内存交换机制

> 移动设备上大容量存储器是闪存(Flash)，读写速度远小于电脑硬盘，使用Swap也不能提升性能。移动设备容量本身就短缺、闪存读写寿命有限，所以没有内存交换机制

* 内存警告：内存不够用时，iOS会发出内存警告，告知进程去清理自己的内存。
* OOM崩溃：Out of Memory Crash

### 2、iOS系统内存占用

内存页的分类：clean memory和dirty memory两种，iOS中有compressed memory概念。

clean memory指能够进行Page Out的部分，对iOS来说指能够被重新创建的内存，如：

* app的二进制可执行文件
* framework的`_DATA_CONST`段
* 文件映射的内存
* 未写入数据的内存

所有不属于 clean memory 的内存都是 dirty memory。这部分内存不能被系统重新创建。

Compressed memory指当物理内存不够用时，iOS将部分物理内存压缩，在需要读写时在解压，以达到节约内存的目的。

### 3、iOS App内存管理

每个进程都有独立的虚拟内存地址空间。每个区实际上都存储相应的内容，其中代码区、常量区、静态区这三个区都是自动加载，在进程结束后被系统释放。

栈区一般存放局部变量、临时变量，由编译器自动分配和释放，每个进程运行时都对应一个栈。

堆区用于动态内存的申请，由程序员分配和释放。

<figure><img src="../.gitbook/assets/image (2) (1).png" alt=""><figcaption><p>iOS app进程空间</p></figcaption></figure>

内存管理方式：

* 引用计数法
* 标记-清除算法（Mark Sweep GC）
* 可达性算法（Tracing GC）

引用计数由于只记录对象的引用次数，是一个局部信息，缺乏全局信息，可能产生循环引用的问题

引用计数在生命周期结束时就立刻被回收，不需要等到全局遍历。

### 4、OOM崩溃

Jetsam 机制(Memorystatus)：Jetsam 会始终监控内存整体使⽤情况，当内存不⾜时会根据优先级、内存占⽤⼤⼩杀掉⼀些进程，并记录成 JetsamEvent 。

内核会调起⼀个内核优先级最⾼的线程监控内存警告，维护了两个列表：

* 基于优先级的进程列表
* 每个进程消耗的内存页的列表

此线程会监听内核pageout线程对整体内存使用情况的通知，在内存告急时向每个进程转发内存警告。

OOM分为FOOM和BOOm，FOOM是app在前台由于内存消耗过大而被系统kill，表现为crash。OOM常见原因：

* 内存泄露
* UIWebView缺陷
* 大图片、大视图

## 三、内存常见问题

#### 1、操作系统内存不够怎么办？

* 内存回收：把不常用的内存淘汰掉，如LRU算法回收内存
* 内存置换：把不常用内存通过交换分区写入磁盘
* 杀死进程：内存紧张时通过OOM，选择kill掉一些进程释放一些内存

#### 2、什么是交换分区Swap

进程占用内存很大，会导致内存消耗完，为解决该问题操作系统中运用Swap技术，拿部分硬盘空间来充当内存使用

访问数据被Swap换出：

* 物理内存是有限资源，运行多进程时并不是每个进程都活跃，系统会启动内存页面置换
* 将长时间未使用物理内存帧放到swap分区，让出资源给其他进程
* 当存在swap分区的页面被访问时就会触发Page Fault缺页异常，从而在置换回物理内存

#### 3、内存置换算法

选择调出页面的算法就称为页面置换算法，决定应该换出哪个页面。

页面的换入换出需要有磁盘的I/O，会有较大的开销。

* 最佳置换算法：没法预知哪个页未来不被访问，无法实现
* 先进先出页面置换算法：优先淘汰最早进入内存的页面
* 最近最久未使用置换算法：选择最近最长时间未访问过的页面进行淘汰
* 时钟置换算法：性能和开销较均衡的算法

#### 4、内存管理主要做什么

* 内存的分配和回收：对进程所需的内存进行分配和释放，malloc函数(申请内存)、free函数(释放内存)
* 地址转换：将程序中的虚拟地址转换成内存中的物理地址
* 内存扩充：当系统没有足够内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存
* 内存映射：将一个文件映射到进程的进程空间中，通过内存指针来读写内存的方式直接读取文件内容，速度更快
* 内存优化：通过调整内存分配策略和回收算法来优化内存使用效率
* 内存安全：保证进程间使用内存互不干扰

#### 5、什么是内存碎片

内存碎片是由内存的申请和释放产生的，通常分为以下两种：

* 内部内存碎片：已经分配给进程使用但未被使用的内存
* 外部内存碎片：指那些并未分配给进程但又不能使用的内存

#### 6、为什么要有堆？

为了保存程序在运行时产生的全局变量

数据段：只能保存在编译时产生的变量

栈：只能在当前方法内部保存变量



## 其他：

### **局部性原理**

被使⽤过的存储器内容在未来可能会被多次使⽤，以及它附近的内容也⼤概率被使⽤。

* 时间局部性：现在访问的指令、数据在不久后很可能会被再次访问
* 空间局部性：现在访问的内存单元周围的内存空间，很可能在不久后被访问

